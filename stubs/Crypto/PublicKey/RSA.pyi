from typing import Callable, Union, Tuple

__all__ = ['generate', 'construct', 'import_key',
           'RsaKey', 'oid']


class RsaKey(object):
    def __init__(self, **kwargs: int) -> None: ...
    @property
    def n(self) -> int: ...
    @property
    def e(self) -> int: ...
    @property
    def d(self) -> int: ...
    @property
    def p(self) -> int: ...
    @property
    def q(self) -> int: ...
    @property
    def u(self) -> int: ...
    def size_in_bits(self) -> int: ...
    def size_in_bytes(self) -> int: ...
    def has_private(self) -> bool: ...
    def can_encrypt(self) -> bool: ...  # legacy
    def can_sign(self) -> bool:...     # legacy
    def publickey(self) -> RsaKey: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __getstate__(self) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def export_key(self, format: str, passphrase: str, pkcs: int,
                   protection: str, randfunc: Callable) -> bytes: ...

    # Backward compatibility
    exportKey = export_key

def generate(bits: int, randfunc: Callable, e: int) -> RsaKey: ...
def construct(rsa_components: Union[Tuple[int, int], #  n, e
                                    Tuple[int, int, int], #  n, e, d
                                    Tuple[int, int, int, int, int], #  n, e, d, p, q
                                    Tuple[int, int, int, int, int, int]], #  n, e, d, p, q, crt_q
              consistency_check: bool) -> RsaKey: ...
def import_key(extern_key: Union[str, bytes], passphrase: str=None) -> RsaKey: ...

# Backward compatibility
importKey = import_key

oid: str